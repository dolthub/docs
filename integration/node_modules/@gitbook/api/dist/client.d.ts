export interface Error {
    error: {
        code: number;
        message: string;
    };
}
export interface List {
    next?: {
        page: string;
    };
    /** Total count of objects in the list */
    count?: number;
}
/**
 * @format uri
 */
export declare type URL = string;
/**
 * @format date
 */
export declare type Date = string;
export interface RequestSpaceTrackPageView {
    /** Unique identifier of the page. */
    pageId: string;
    /** Analytics info on the GitBook's content visitor. */
    visitor: {
        anonymousId: string;
        cookies: Record<string, string>;
        userAgent: string;
    };
    /** The GitBook content's URL visited (including URL params). */
    url: string;
    /** The URL of referrer that linked to the page. */
    referrer: string;
}
export interface RequestPublishIntegration {
    /**
     * Base64 content of the icon
     * @format byte
     */
    icon?: string;
    title: any;
    description: any;
    summary?: any;
    previewImages?: string[];
    visibility?: IntegrationVisibility;
    scopes: any;
    categories?: any;
    blocks?: any;
    externalLinks?: any;
    configurations?: IntegrationConfigurations;
    /** Content of the script to use */
    script: string;
    /** The subdomain of the organization under which the integration should be published */
    organization?: string;
    /** Secrets stored on the integration and passed at runtime. */
    secrets?: IntegrationSecrets;
    /**
     * Security policy to validate the content of the integrations scripts and Contentkit. Will be sent as
     * headers when processing the script fetch event and the blocks fetch events.
     *
     */
    contentSecurityPolicy?: IntegrationContentSecurityPolicy;
}
export interface RequestUpdateIntegrationInstallation {
    externalIds?: any;
    configuration?: any;
}
export interface RequestUpgradeOrganizationBilling {
    /** Name of the product */
    product: BillingProduct;
    /** Interval for a billing subscription */
    interval: BillingInterval;
    /** Reason that triggered the billing upgrade */
    reason?: string;
    /**
     * Mode to use for the upgrade (default value is `commit`): - `auto`: user is redirect to checkout if possible, other a preview of the auto-upgrade is returned. - `commit`: a checkout session is returned or an auto-upgrade is done - `preview`: a preview invoice is always returned
     *
     */
    mode?: 'auto' | 'commit' | 'preview';
}
export interface RequestInviteUsersToOrganization {
    emails: (string | {
        email: string;
        role: MemberRoleOrGuest;
    })[];
    /** Default role to set on newly invited members. */
    role?: MemberRoleOrGuest;
    /** If true, invites the user as an SSO user of the organization. Defaults to false. */
    sso?: boolean;
}
export interface RequestImportGitRepository {
    /** URL of the Git repository to import. It can contain basic auth credentials. */
    url: string;
    /** Git ref to import in the format "refs/heads/main" */
    ref: string;
    /** Unique identifier to use to cache the Git repository across multiple operations. */
    repoCacheID?: string;
    /** URL to use as a prefix for external file references. */
    repoTreeURL?: string;
    /** URL to use as a prefix for the commit URL. */
    repoCommitURL?: string;
    /** Path to a root directory for the project in the repository. */
    repoProjectDirectory?: string;
    force?: boolean;
    /** If true, the import will generate a revision without updating the space primary content. */
    standalone?: boolean;
}
export interface RequestExportToGitRepository {
    /** URL of the Git repository to export to. It can contain basic auth credentials. */
    url: string;
    /** Git ref to push the commit to in the format "refs/heads/main" */
    ref: string;
    /** Message for the commit generated by the export */
    commitMessage: string;
    /** Unique identifier to use to cache the Git repository across multiple operations. */
    repoCacheID?: string;
    /** URL to use as a prefix for external file references. */
    repoTreeURL?: string;
    /** URL to use as a prefix for the commit URL. */
    repoCommitURL?: string;
    /** Path to a root directory for the project in the repository. */
    repoProjectDirectory?: string;
    force?: boolean;
}
export interface RequestImportContent {
    /** URL of the content to import. */
    url: string;
    source: ImportContentSource;
}
export interface RequestCreateChangeRequest {
    /** Subject of the change-request */
    subject?: string;
}
export interface RequestRenderIntegrationUI {
    /** ID of the component to render in the integration. */
    componentId: string;
    /** ID of the space to render. */
    spaceId: string;
    /** Current properties of the UI. */
    props: object;
    /** Current local state of the UI. */
    state?: object;
    context: ContentKitContext;
    /** Custom action to re-render the block. */
    action?: ContentKitAction;
}
export interface ApiInformation {
    /** Current release of GitBook */
    version: string;
    /** Date of the latest release in ISO format */
    build: string;
}
/**
 * The context to send when purging the CDN Cache
 */
export interface RequestPurgeCDNCacheContext {
    /** The type of purge, e.g by tags or hosts */
    type: PurgeCDNCacheContextType;
    /** The list of tags or hosts to purge */
    values: string[];
}
/**
 * The context to send when blocking/unblocking a user
 */
export interface RequestBlockUserContext {
    block: boolean;
}
/**
 * The context to send when triggering a content indexing.
 */
export interface TriggerContentIndexingContext {
    /** The unique identifier of the Space to index. */
    spaceId: string;
    /** Whether to force a complete re-indexing of the Space. */
    force: boolean;
}
export interface User {
    /** Type of Object, always equals to "user" */
    object: 'user';
    /** Unique identifier for the user */
    id: string;
    /** Full name for the user */
    displayName: string;
    /** Email address of the user */
    email?: string;
    /** URL of the user's profile picture */
    photoURL?: string;
}
export interface UserTarget {
    user?: string;
}
/**
* * `public`: Anyone can access the content, and the content is indexed by search engines.
* `unlisted`: Anyone can access the content, and the content is not indexed by search engines
* `share-link`: Anyone with a secret token in the url can access the content.
* `visitor-auth`: Anyone authenticated through a JWT token can access the content.
* `in-collection`: Anyone who can access the parent collection can access the content.
  Only available for spaces in a collection.
* `private`: Authorized members can access the content.
*/
export declare enum ContentVisibility {
    Public = "public",
    Unlisted = "unlisted",
    ShareLink = "share-link",
    VisitorAuth = "visitor-auth",
    InCollection = "in-collection",
    Private = "private"
}
export interface ImportContentResult {
    /** ID of the newly created revision. */
    revision: string;
    /** How many resources were imported */
    importedResources: number;
    /** How many resources were processed */
    totalResources: number;
}
export interface Space {
    /** Type of Object, always equals to "space" */
    object: 'space';
    /** Unique identifier for the space */
    id: string;
    /** Title of the space */
    title: string;
    /**
     * * `public`: Anyone can access the content, and the content is indexed by search engines.
     * * `unlisted`: Anyone can access the content, and the content is not indexed by search engines
     * * `share-link`: Anyone with a secret token in the url can access the content.
     * * `visitor-auth`: Anyone authenticated through a JWT token can access the content.
     * * `in-collection`: Anyone who can access the parent collection can access the content.
     *   Only available for spaces in a collection.
     * * `private`: Authorized members can access the content.
     *
     */
    visibility: ContentVisibility;
    createdAt: Date;
    updatedAt: Date;
    /** URLs associated with the object */
    urls: {
        app: string;
        published?: string;
        public?: string;
    };
}
export interface Revision {
    /** Type of Object, always equals to "revision" */
    object: 'revision';
    /** Unique identifier for the revision */
    id: string;
    /** IDs of the parent revisions */
    parents: string[];
    pages: RevisionPage[];
    files: RevisionFile[];
    /** Metadata about a potential associated git commit. */
    git?: {
        oid: string;
        message: string;
        createdByGitBook: boolean;
        url?: string;
    };
    urls: {
        app: string;
        published?: string;
        public?: string;
    };
}
export declare type RevisionPage = RevisionPageSheet | RevisionPageGroup | RevisionPageLink;
export interface RevisionPageBase {
    /** Unique identifier for the page in the revision */
    id: string;
    /** Title of the page */
    title: string;
}
export declare type RevisionPageSheet = RevisionPageBase & {
    kind: 'sheet';
    slug: string;
    path: string;
    description?: string;
    pages: (RevisionPageSheet | RevisionPageLink)[];
} & ({
    markdown: string;
} | {
    document: PageDocument;
} | object);
export declare type RevisionPageGroup = RevisionPageBase & {
    kind: 'group';
    slug: string;
    path: string;
    pages: (RevisionPageSheet | RevisionPageLink)[];
};
export declare type RevisionPageLink = RevisionPageBase & {
    kind: 'link';
    href?: string;
};
export interface RevisionFile {
    id: string;
    name: string;
    contentType: string;
    downloadURL: string;
}
export interface PageDocument {
    nodes: object[];
}
export declare enum ImportContentSource {
    Website = "website",
    Docx = "docx",
    Markdown = "markdown",
    Html = "html",
    Zip = "zip",
    Confluence = "confluence",
    GithubWiki = "github-wiki",
    DropboxPaper = "dropbox-paper",
    Notion = "notion",
    Quip = "quip",
    GoogleDocs = "google-docs",
    OpenApi = "open-api"
}
export interface Organization {
    /** Type of Object, always equals to "organization" */
    object: 'organization';
    /** Unique identifier for the organization */
    id: string;
    /** Name of the organization */
    title: string;
}
/**
* "The role of a member in an organization.
"admin": Can administrate the content: create, delete spaces, ...
"create": Can create content.
"review": Can review content.
"edit": Can edit the content (live or change requests).
"comment": Can access the content and its discussions.
"read": Can access the content, but cannot update it in any way.
*/
export declare enum MemberRole {
    Admin = "admin",
    Create = "create",
    Edit = "edit",
    Review = "review",
    Comment = "comment",
    Read = "read"
}
/**
 * The role of a member in an organization, null for guests
 */
export declare type MemberRoleOrGuest = MemberRole | null;
export interface OrganizationTransferResponse {
    /** The unique id of the collection created in the target organization containing the content of the source organization. */
    collection: string;
    /** The new hostname if the source organization needed to change hostname. */
    newSourceHostname?: string;
}
export interface OrganizationDirectorySyncGroup {
    /** The unique identifier of this group in WorkOS. Not the unique ID from GitBook. */
    id: string;
    /** The identity provider's unique ID for this group, should be used to generate the team's unique ID when syncing the groups. */
    idp_id: string;
    /** The unique ID of the directory this group is owned by in WorkOS. Is not a unique ID from our database. */
    directory_id: string;
    /** The name of the group from the identity provider, it should always be set according to the WorkOS documentation. */
    name: string;
    /** The unique ID of the GitBook team already synced to this group, if applicable. */
    teamKey?: string;
}
export declare type OrganizationDirectorySyncGroupTeamStatus = {
    success: true;
    group_id: string;
    team_id: string;
} | {
    success: false;
    error: string;
} | ({
    success: true;
    group_id: string;
    team_id: string;
} & {
    success: false;
    error: string;
});
export interface OrganizationTarget {
    organization?: string;
}
export interface OrganizationMember {
    /** Type of Object, always equals to "member" */
    object: 'member';
    /** Unique identifier for the user. */
    id: string;
    /** The role of a member in an organization, null for guests */
    role: MemberRoleOrGuest;
    user: User;
    /** Whatever the membership of this user is disabled and prevent them from accessing content. */
    disabled: boolean;
    /** Date at which the user joined the organization. */
    joinedAt: Date;
}
export interface OrganizationTeam {
    /** Type of Object, always equals to "team" */
    object: 'team';
    /** Unique identifier for the team. */
    id: string;
    /** Title of the team. */
    title: string;
    /** Count of members in this team. */
    members: number;
    /** Date at which the team was created. */
    createdAt: Date;
}
export interface ChangeRequest {
    /** Type of Object, always equals to "change-request" */
    object: 'change-request';
    /** Unique identifier for the change request */
    id: string;
    /** Incremental identifier of the change request */
    number: number;
    status: ChangeRequestStatus;
    /** Subject of the change request */
    subject: string;
    createdBy: User;
    createdAt: Date;
    updatedAt: Date;
    /** URLs associated with the object */
    urls: {
        app: string;
    };
}
export declare enum ChangeRequestStatus {
    Draft = "draft",
    Open = "open",
    Archived = "archived",
    Merged = "merged"
}
/**
 * Permission of a user in a content.
 */
export interface UserContentPermission {
    /**
     * "The role of a member in an organization.
     * "admin": Can administrate the content: create, delete spaces, ...
     * "create": Can create content.
     * "review": Can review content.
     * "edit": Can edit the content (live or change requests).
     * "comment": Can access the content and its discussions.
     * "read": Can access the content, but cannot update it in any way.
     *
     */
    permission: MemberRole;
    user: User;
}
/**
 * Permission of a member in a content.
 */
export interface MemberContentPermission {
    /**
     * "The role of a member in an organization.
     * "admin": Can administrate the content: create, delete spaces, ...
     * "create": Can create content.
     * "review": Can review content.
     * "edit": Can edit the content (live or change requests).
     * "comment": Can access the content and its discussions.
     * "read": Can access the content, but cannot update it in any way.
     *
     */
    permission: MemberRole;
    space: Space;
}
/**
 * Search result representing a space.
 */
export interface SearchSpaceResult {
    id: string;
    title: string;
    pages: SearchPageResult[];
}
/**
 * Search result representing a page in a space.
 */
export interface SearchPageResult {
    id: string;
    title: string;
    path: string;
    sections?: SearchSectionResult[];
    /** URLs associated with the object */
    urls: {
        app: string;
    };
}
/**
 * Search result representing a section in a page.
 */
export interface SearchSectionResult {
    id: string;
    title: string;
    path: string;
    body: string;
    /** URLs associated with the object */
    urls: {
        app: string;
    };
}
/**
 * Answer from AI for a question asked on a content.
 */
export interface SearchAIAnswer {
    text: string;
    pages: {
        page: string;
        revision: string;
        space: string;
        sections: string[];
    }[];
}
export declare enum AnalyticsSearchPeriod {
    LastMonth = "last_month",
    LastWeek = "last_week",
    LastYear = "last_year"
}
/**
 * Analytics entry for a search query.
 */
export interface AnalyticsSearchQuery {
    query: string;
    /** Number of searches done by users. */
    searches: number;
    /** Number of objects matching this search. */
    hits: number;
    /** Number of pages matching this search. */
    pageHits: number;
    /** Number of sections matching this search. */
    sectionHits: number;
}
/**
 * Top search queries for a content.
 */
export interface AnalyticsTopSearches {
    /** Number of searches done by users. */
    searches: number;
    /** Top queries searched for this content. */
    queries: AnalyticsSearchQuery[];
}
export declare enum AnalyticsTrafficInterval {
    Daily = "daily",
    Weekly = "weekly",
    Monthly = "monthly"
}
export interface AnalyticsTrafficPageViews {
    /** Total number of page views over the period. */
    count: number;
    /** Page views per interval (day, week, month). */
    views: {
        timestamp: string;
        count: number;
    }[];
}
export interface AnalyticsContentPages {
    pages: AnalyticsContentPage[];
}
/**
 * Page entry in the content analytics.
 */
export interface AnalyticsContentPage {
    page: string;
    title: string;
    pageViews: number;
    feedbacks?: {
        score: number;
        total: number;
        rating: 'unknown' | 'bad' | 'ok' | 'good';
        bad: number;
        ok: number;
        good: number;
    };
}
export interface Collection {
    /** Type of Object, always equals to "collection" */
    object: 'collection';
    /** Unique identifier for the collection */
    id: string;
    /** Title of the collection */
    title: string;
    /** Path in the published URL */
    path?: string;
    /**
     * * `public`: Anyone can access the content, and the content is indexed by search engines.
     * * `unlisted`: Anyone can access the content, and the content is not indexed by search engines
     * * `share-link`: Anyone with a secret token in the url can access the content.
     * * `visitor-auth`: Anyone authenticated through a JWT token can access the content.
     * * `in-collection`: Anyone who can access the parent collection can access the content.
     *   Only available for spaces in a collection.
     * * `private`: Authorized members can access the content.
     *
     */
    visibility: ContentVisibility;
    publishingType?: 'variants';
    /** ID of the primary space for this collection */
    primarySpace?: string;
    /** ID of the parent collection, if any */
    collection?: string;
}
export interface Integration {
    object: 'integration';
    /** Unique named identifier for the integration */
    name: string;
    /** Title of the integration */
    title: string;
    /** Description of the integration */
    description?: string;
    /** Long form markdown summary of the integration */
    summary?: string;
    /** URLs of images to showcase the integration */
    previewImages: string[];
    visibility: IntegrationVisibility;
    /** Permissions that should be granted to the integration */
    scopes: IntegrationScope[];
    /** Categories for which the integration is listed in the marketplace */
    categories: IntegrationCategory[];
    /** Custom blocks defined by this integration. */
    blocks?: IntegrationBlock[];
    configurations?: IntegrationConfigurations;
    /** External urls configured by the developer of the integration */
    externalLinks: {
        url: URL;
        label: string;
    }[];
    /** URLs associated with the object */
    urls: {
        icon?: string;
        app: string;
        assets: string;
        publicEndpoint: string;
    };
    /**
     * Security policy to validate the content of the integrations scripts and Contentkit. Will be sent as
     * headers when processing the script fetch event and the blocks fetch events.
     *
     */
    contentSecurityPolicy?: IntegrationContentSecurityPolicy;
}
export declare enum IntegrationScope {
    SpaceViewsRead = "space:views:read",
    SpaceContentRead = "space:content:read",
    SpaceContentWrite = "space:content:write",
    SpaceMetadataRead = "space:metadata:read",
    SpaceMetadataWrite = "space:metadata:write",
    SpaceScriptInject = "space:script:inject",
    SpaceScriptCookies = "space:script:cookies"
}
/**
 * Format the custom block as a codeblock
 */
export declare type IntegrationBlockMarkdown = {
    codeblock: string;
    body: string;
};
export interface IntegrationBlock {
    /** Unique ID in the integration for the block. It also represents the UI component used. */
    id: string;
    /** Short descriptive title for the block. */
    title: string;
    /** Long descriptive text for the block. */
    description?: string;
    /** URL of the icon to represent this block. */
    icon?: string;
    /** URLs patterns to convert as this block. */
    urlUnfurl?: string[];
    /** Format the custom block as a codeblock */
    markdown?: IntegrationBlockMarkdown;
}
/**
 * Describe whether all spaces have been selected or there's a selection involved
 */
export declare enum IntegrationInstallationSpaceSelection {
    All = "all",
    Selected = "selected"
}
export declare enum IntegrationCategory {
    Analytics = "analytics",
    Collaboration = "collaboration",
    Marketing = "marketing",
    Content = "content",
    Other = "other"
}
export interface IntegrationConfigurations {
    /** Schema for a configuration */
    account?: IntegrationConfiguration;
    /** Schema for a configuration */
    space?: IntegrationConfiguration;
}
/**
 * Schema for a configuration
 */
export interface IntegrationConfiguration {
    properties: Record<string, {
        title?: string;
        description?: string;
    } & ({
        type: 'string';
        default?: string;
    } | {
        type: 'number';
        default?: number;
    } | {
        type: 'boolean';
        default?: boolean;
    } | {
        type: 'button';
        callback_url: string;
        button_text: string;
    })>;
    required?: string[];
}
export declare enum IntegrationVisibility {
    Public = "public",
    Private = "private"
}
/**
 * Installation of an integration on an account
 */
export interface IntegrationInstallation {
    id: string;
    status: IntegrationInstallationStatus;
    /** Describe whether all spaces have been selected or there's a selection involved */
    space_selection: IntegrationInstallationSpaceSelection;
    /** Configuration of the integration at the account level */
    configuration: object;
    /** URLs associated with the object */
    urls: {
        app: string;
        publicEndpoint: string;
    };
    /** External IDs assigned by the integration. */
    externalIds: string[];
    /** Target of the integration installation */
    target: IntegrationInstallationTarget;
}
/**
 * Installation of an integration at a space level
 */
export interface IntegrationSpaceInstallation {
    /** ID of the space the integration is installed on. */
    space: string;
    status: IntegrationInstallationStatus;
    /** Configuration of the integration for this space */
    configuration: object;
    externalIds: any;
    /** URLs associated with the object */
    urls: {
        publicEndpoint: string;
    };
}
export declare enum IntegrationInstallationStatus {
    Active = "active",
    Pending = "pending",
    Paused = "paused"
}
/**
 * Secrets stored on the integration and passed at runtime.
 */
export declare type IntegrationSecrets = Record<string, string>;
/**
 * Runtime environment provided during the execution of integration's code.
 */
export interface IntegrationEnvironment {
    /** URL of the HTTP API */
    apiEndpoint: string;
    /** Authentication token to use with the HTTP API */
    authToken?: string;
    integration: Integration;
    /** Installation of an integration on an account */
    installation?: IntegrationInstallation;
    /** Installation of an integration at a space level */
    spaceInstallation?: IntegrationSpaceInstallation;
    /** Secrets stored on the integration and passed at runtime. */
    secrets: IntegrationSecrets;
}
export declare type IntegrationInstallationTarget = UserTarget | OrganizationTarget;
/**
* Security policy to validate the content of the integrations scripts and Contentkit. Will be sent as
headers when processing the script fetch event and the blocks fetch events.
*/
export declare type IntegrationContentSecurityPolicy = string | {
    'base-uri'?: string;
    'block-all-mixed-content'?: string;
    'child-src'?: string;
    'connect-src'?: string;
    'default-src'?: string;
    'font-src'?: string;
    'form-action'?: string;
    'frame-ancestors'?: string;
    'frame-src'?: string;
    'img-src'?: string;
    'manifest-src'?: string;
    'media-src'?: string;
    'navigate-to'?: string;
    'object-src'?: string;
    'plugin-types'?: string;
    'prefetch-src'?: string;
    referrer?: string;
    'report-to'?: string;
    'report-uri'?: string;
    'require-sri-for'?: string;
    'require-trusted-types-for'?: string;
    sandbox?: string;
    'script-src'?: string;
    'script-src-attr'?: string;
    'script-src-elem'?: string;
    'style-src'?: string;
    'style-src-attr'?: string;
    'style-src-elem'?: string;
    'trusted-types'?: string;
    'upgrade-insecure-requests'?: string;
    'worker-src'?: string;
};
/**
 * Any event that can be received from GitBook.
 */
export declare type Event = InstallationSetupEvent | SpaceInstallationSetupEvent | SpaceViewEvent | SpaceContentUpdatedEvent | SpaceGitSyncCompletedEvent | SpaceGitSyncStartedEvent | SpaceVisibilityUpdatedEvent | FetchEvent | FetchPublishedScriptEvent | UIRenderEvent;
/**
 * Common properties for all events.
 */
export interface BaseEvent {
    /** Unique identifier for the event. */
    eventId: string;
    /** Type of the event. */
    type: string;
}
/**
 * Common properties for all events related to an installation
 */
export declare type InstallationEvent = BaseEvent & {
    installationId: string;
};
/**
 * Common properties for all events related to a specific space.
 */
export declare type SpaceEvent = InstallationEvent & {
    spaceId: string;
};
/**
 * Event received when integration has been installed or updated.
 */
export declare type InstallationSetupEvent = InstallationEvent & {
    type: 'installation_setup';
    status: IntegrationInstallationStatus;
    previous?: {
        status: IntegrationInstallationStatus;
        configuration?: object;
    };
};
/**
 * Event received when integration has been installed or updated on a space.
 */
export declare type SpaceInstallationSetupEvent = SpaceEvent & {
    type: 'space_installation_setup';
    status: IntegrationInstallationStatus;
    previous?: {
        status: IntegrationInstallationStatus;
        configuration?: object;
    };
};
/**
 * Event received when a page has been visited.
 */
export declare type SpaceViewEvent = SpaceEvent & {
    type: 'space_view';
    pageId?: string;
    visitor: {
        anonymousId: string;
        cookies: Record<string, string>;
        userAgent: string;
        ip: string;
    };
    url: string;
    referrer: string;
};
/**
 * Event when the primary content of a space has been updated.
 */
export declare type SpaceContentUpdatedEvent = SpaceEvent & {
    type: 'space_content_updated';
    revisionId: string;
};
/**
 * Event when the visibility of the space has been changed.
 */
export declare type SpaceVisibilityUpdatedEvent = SpaceEvent & {
    type: 'space_visibility_updated';
    previousVisibility: ContentVisibility;
    visibility: ContentVisibility;
};
/**
 * Event when a GitSync operation has been completed.
 */
export declare type SpaceGitSyncCompletedEvent = SpaceEvent & {
    type: 'space_gitsync_completed';
    state: 'success' | 'failure';
    revisionId: string;
    commitId: string;
};
/**
 * Event when a GitSync operation has been started.
 */
export declare type SpaceGitSyncStartedEvent = SpaceEvent & {
    type: 'space_gitsync_started';
    revisionId: string;
    commitId: string;
};
export interface FetchRequest {
    method: 'post' | 'get' | 'put' | 'delete';
    url: string;
    headers: Record<string, string>;
}
/**
 * Event representing an incoming HTTP request.
 */
export declare type FetchEvent = BaseEvent & {
    spaceId?: string;
    installationId?: string;
    auth?: {
        userId: string;
    };
    type: 'fetch';
    request: FetchRequest;
};
/**
 * Common properties for all events related to fetching a published script from an installation
 */
export declare type FetchPublishedScriptEvent = SpaceEvent & {
    type: 'fetch_published_script';
};
/**
 * Event generated when rendering a UI
 */
export declare type UIRenderEvent = SpaceEvent & {
    auth?: {
        userId: string;
    };
    type: 'ui_render';
    componentId: string;
    props: object;
    state?: object;
    context: ContentKitContext;
    action?: object;
};
/**
 * Interval for a billing subscription
 */
export declare enum BillingInterval {
    Monthly = "monthly",
    Yearly = "yearly"
}
export interface BillingPortal {
    /** URL to the billing portal for an organization */
    url: string;
}
/**
 * Name of the product
 */
export declare enum BillingProduct {
    Free = "free",
    Plus = "plus",
    Pro = "pro",
    Team = "team",
    Business = "business",
    Legacy = "legacy",
    Startup = "startup",
    Enterprise = "enterprise"
}
export declare type BillingUpgrade = {
    result: 'checkout';
    sessionId: string;
} | {
    result: 'preview';
    invoice: BillingInvoicePreview;
} | {
    result: 'upgraded';
} | {
    result: 'downgraded';
};
export interface BillingInvoicePreview {
    /** Amount of the invoice */
    amount: number;
    /** Amount that will be immediately charged. */
    amountDueToday: number;
    /** Current balance, if any, being stored on the customer. If positive, the customer has credit to apply to their next invoice. */
    customerBalance: number;
    /** Current balance after potential upgrade. */
    remainingCustomerBalance: number;
    /** Details of the change happening on the subscription. */
    lines: {
        description: string;
        amount: number;
        periodStart: Date;
        periodEnd: Date;
    }[];
}
export declare enum APIIntegrationScope {
    IntegrationRead = "integration:read",
    IntegrationUpdate = "integration:update",
    IntegrationInstallationRead = "integration:installation:read",
    IntegrationInstallationUpdate = "integration:installation:update"
}
export declare type APIScope = IntegrationScope | APIIntegrationScope | (IntegrationScope & APIIntegrationScope);
/**
 * The Cloudflare Hostname status
 */
export declare enum CloudflareHostnameStatus {
    Pending = "pending",
    Active = "active",
    Blocked = "blocked",
    Moved = "moved",
    Deleted = "deleted"
}
/**
 * The Cloudflare Hostname TLS certificate
 */
export interface CloudflareHostnameTLSCertificate {
    issuer?: string;
    expiresOn?: string;
    issuedOn?: string;
}
/**
 * The Cloudflare Hostname TLS information
 */
export interface CloudflareHostnameTLSInfo {
    /** The Cloudflare Hostname TLS status */
    status: CloudflareHostnameTLSStatus;
    /** The Cloudflare Hostname TLS validation method */
    method: CloudflareHostnameTLSValidationMethod;
    certificateAuthority?: string;
    certificates: CloudflareHostnameTLSCertificate[];
    validationErrors: CloudflareHostnameTLSValidationError[];
}
/**
 * The Cloudflare Hostname TLS status
 */
export declare enum CloudflareHostnameTLSStatus {
    Initializing = "initializing",
    PendingValidation = "pending_validation",
    PendingIssuance = "pending_issuance",
    PendingDeployment = "pending_deployment",
    Active = "active",
    PendingDeletion = "pending_deletion",
    PendingCleanup = "pending_cleanup",
    Deleted = "deleted"
}
/**
 * The Cloudflare Hostname TLS validation error
 */
export interface CloudflareHostnameTLSValidationError {
    message: string;
}
/**
 * The Cloudflare Hostname TLS validation method
 */
export declare enum CloudflareHostnameTLSValidationMethod {
    Http = "http",
    Txt = "txt",
    Email = "email"
}
/**
 * Cloudflare Custom Domain's information
 */
export interface CustomDomainInfo {
    hostname: string;
    /** The Cloudflare Hostname status */
    status: CloudflareHostnameStatus;
    createdAt: string;
    /** The Cloudflare Hostname TLS information */
    ssl?: CloudflareHostnameTLSInfo;
    verificationErrors: string[];
}
/**
 * The User Firebase Auth Info.
 */
export interface FirebaseUserInfo {
    uid: string;
    displayName?: string;
    email?: string;
    phoneNumber?: string;
    photoUrl?: string;
    providerId?: string;
}
/**
 * The type of purge, e.g by tags or hosts
 */
export declare enum PurgeCDNCacheContextType {
    Tags = "tags",
    Hosts = "hosts"
}
/**
 * The GitBook Staff User info.
 */
export interface StaffUserInfo {
    id: string;
    searchKey: string;
}
/**
 * The GitBook User info shown in the BackOffice.
 */
export interface UserBackOfficeInfo {
    id: string;
    /** The GitBook User risk evaluation. */
    riskEvaluation: UserRiskEvaluation;
    authProviders: FirebaseUserInfo[];
    createdAt: string;
    lastSignInAt: string;
    disabled: boolean;
}
/**
 * The info returned when impersonating a GitBook User.
 */
export declare type UserImpersonation = UserBackOfficeInfo & {
    impersonation: UserImpersonationInfo;
};
/**
 * The GitBook User impersonation info.
 */
export interface UserImpersonationInfo {
    authURL: string;
    impersonatorId: string;
}
/**
 * The GitBook User risk evaluation.
 */
export interface UserRiskEvaluation {
    /** True if the user was originally considered as risky */
    wasRisky: boolean;
    /** True if the user is currently considered as risky */
    isRisky: boolean;
    /** True if the user went through the verification process */
    isVerified: boolean;
    /** Risk score of the user */
    riskScore: number;
    /** Number of verification steps completed by the user */
    completedSteps: number;
    /** Total number of verification steps expected */
    expectedSteps: number;
    /** User completed the Google Account verification step */
    googleLogin: boolean;
    /** User completed the GitHub Account verification step */
    githubLogin: boolean;
    /** User completed the Email verification step */
    emailVerified: boolean;
    activeDaysRemaining: number;
}
export interface UnsplashImage {
    kind: 'unsplash_image';
    id: string;
    description: string;
    downloadLocation: string;
    urls: {
        full: string;
        small: string;
    };
    author: {
        name: string;
        url: string;
    };
}
export interface APITemporaryToken {
    /** Temporary access token to authenticate with the API */
    token: string;
}
export declare type ContentKitContext = {
    type: 'document';
    editable: boolean;
    theme: 'dark' | 'light';
};
/**
 * Binding between a property and a state value.
 */
export interface ContentKitDynamicBinding {
    /** Key in the state */
    $state: string;
}
/**
 * Higher level element to represent a custom block.
 */
export interface ContentKitBlock {
    type: 'block';
    children: ContentKitDescendantElement[];
    controls?: (ContentKitBlockControl | ContentKitBlockControl[])[];
}
/**
 * Control menu item displayed for the block.
 */
export interface ContentKitBlockControl {
    icon?: ContentKitIcon;
    label: string;
    /** Custom action to re-render the block. */
    onPress: ContentKitAction;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
/**
 * Pressable button triggering an action.
 */
export interface ContentKitButton {
    type: 'button';
    style?: 'primary' | 'secondary' | 'danger';
    /** Custom action to re-render the block. */
    onPress: ContentKitAction;
    icon?: ContentKitIcon;
    label?: string;
    tooltip?: string;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
    disabled?: boolean;
}
/**
 * Text input to prompt the user.
 */
export interface ContentKitTextInput {
    type: 'textinput';
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Text value to initialize the input with. */
    initialValue?: string;
    /** Text that appears in the form control when it has no value set */
    placeholder?: string;
    multiline?: boolean;
}
/**
 * Low level text element.
 */
export interface ContentKitText {
    type: 'text';
    style?: 'bold' | 'italic' | 'code' | 'strikethrough';
    children: (string | ContentKitText)[];
}
export interface ContentKitBox {
    type?: 'box';
    /** specifies how much of the remaining space in the container should be assigned to the element */
    grow?: number;
    children?: ContentKitDescendantElement[];
}
/**
 * Horizontal stack of boxes.
 */
export interface ContentKitHStack {
    type: 'hstack';
    align?: 'start' | 'center' | 'end';
    children: ContentKitDescendantElement[];
}
/**
 * Vertical stack of boxes.
 */
export interface ContentKitVStack {
    type: 'vstack';
    align?: 'start' | 'center' | 'end';
    children: ContentKitDescendantElement[];
}
/**
 * Divider between 2 boxes in a stack.
 */
export interface ContentKitDivider {
    type: 'divider';
    size?: 'small' | 'medium' | 'large';
}
/**
 * Custom action to re-render the block.
 */
export declare type ContentKitAction = {
    action: string;
    [key: string]: any;
} | ContentKitDefaultAction | ({
    action: string;
    [key: string]: any;
} & ContentKitDefaultAction);
/**
 * Action to open an overlay modal defined by "componentId".
 */
export declare type ContentKitDefaultAction = {
    action: '@ui.modal.open';
    componentId: string;
    props: object;
} | {
    action: '@ui.modal.close';
    returnValue: object;
} | {
    action: '@ui.url.open';
    url: string;
} | {
    action: '@link.unfurl';
    url: string;
} | {
    action: '@editor.node.updateProps';
    props: object;
};
export declare enum ContentKitIcon {
    Close = "close",
    Edit = "edit",
    Github = "github",
    Maximize = "maximize",
    Email = "email",
    Settings = "settings",
    Search = "search",
    Delete = "delete",
    Star = "star",
    Warning = "warning",
    Link = "link",
    LinkExternal = "link-external"
}
/**
 * Overlay modal.
 */
export interface ContentKitModal {
    type: 'modal';
    title?: string;
    subtitle?: ContentKitInlineElement[];
    size?: 'medium' | 'xlarge' | 'fullscreen';
    /** Data passed back to the parent view when the modal is closed. These data are accessible in the "@ui.modal.close" */
    returnValue?: object;
    children: ContentKitDescendantElement[];
    /** Pressable button triggering an action. */
    submit?: ContentKitButton;
}
/**
 * Frame for a webpage
 */
export interface ContentKitWebFrame {
    type: 'webframe';
    /** Ratio between width and height. Used to size the webframe. */
    aspectRatio?: number;
    /** Content to load in the frame. */
    source: {
        url: string;
    };
    /** Controls button shown as an overlay in a corner of the frame. */
    buttons?: ContentKitButton[];
    /** Data to communicated to the webframe's content. Each state update will cause the webframe to receive a message. */
    data?: Record<string, string | ContentKitDynamicBinding>;
}
/**
 * Code block with syntax highlighting
 */
export interface ContentKitCodeBlock {
    type: 'codeblock';
    /** Code content to display */
    content: ContentKitDynamicBinding | string;
    /** Syntax to use for highlighting (ex: javascript, python) */
    syntax?: string;
    /** Line number to start at. */
    lineNumbers?: boolean | number;
    /** Controls button shown as an overlay in a corner of the code block. */
    buttons?: ContentKitButton[];
    /** State binding when editable. The value of the input will be stored as a property in the state named after this ID. */
    state?: string;
    /** Custom action to re-render the block. */
    onContentChange?: ContentKitAction;
    /** Header displayed before the code lines */
    header?: ContentKitDescendantElement[];
    /** Footer displayed after the code lines */
    footer?: ContentKitDescendantElement[];
}
/**
 * Output of the integration when rendering an UI.
 */
export interface ContentKitRenderOutput {
    /** Element used as root */
    element: ContentKitRootElement;
    state: object;
    props: object;
}
/**
 * Block with rich text formatting of a markdown content.
 */
export interface ContentKitMarkdown {
    type: 'markdown';
    /** Markdown content to display */
    content: ContentKitDynamicBinding | string;
}
export interface ContentKitCard {
    type: 'card';
    title?: string;
    hint?: string | ContentKitInlineElement[];
    icon?: ContentKitIcon | ContentKitImage;
    /** Custom action to re-render the block. */
    onPress?: ContentKitAction;
    children?: ContentKitDescendantElement[];
    /** Buttons displayed in the top right corner of the card. */
    buttons?: ContentKitButton[];
}
export interface ContentKitImage {
    type: 'image';
    source: {
        url: string;
    };
    aspectRatio: number;
}
/**
 * Field for an input.
 */
export interface ContentKitInput {
    type: 'input';
    /** Text label displayed next to the input. */
    label: string;
    hint?: string | ContentKitInlineElement;
    element: ContentKitTextInput | ContentKitSelect | ContentKitSwitch | ContentKitRadio | ContentKitCheckbox | ContentKitButton;
}
/**
 * An individual option in a select element
 */
export interface ContentKitSelectOption {
    id: string;
    label: string;
}
/**
 * Creates a drop down menu with a list of options for a user to choose.
 */
export interface ContentKitSelect {
    type: 'select';
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to initialize the select with. */
    initialValue?: string | string[];
    /** Text that appears in the form control when it has no value set */
    placeholder?: string;
    /** Should the select accept the selection of multiple options. If true, the state will be an array. */
    multiple?: boolean;
    /** Static list of options */
    options: ContentKitSelectOption[] | {
        url: string;
    };
}
/**
 * Renders a boolean input.
 */
export interface ContentKitSwitch {
    type: 'switch';
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to initialize the switch with. */
    initialValue?: boolean;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
export interface ContentKitCheckbox {
    type: 'checkbox';
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to store in a state array when the checkbox is selected. */
    value: string | number;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
export interface ContentKitRadio {
    type: 'radio';
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to store in th state when the checkbox is selected. */
    value: string | number;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
/**
 * A confirm object that defines an optional confirmation dialog after the input is clicked.
 */
export interface ContentKitConfirm {
    /** A text value that defines the dialog's title. */
    title: string;
    /** A text value that defines the explanatory text that appears in the confirm dialog. */
    text: string;
    /** A text value to define the text of the button that confirms the action. */
    confirm: string;
    style?: 'primary' | 'danger';
}
/**
 * Element used as root
 */
export declare type ContentKitRootElement = ContentKitBlock | ContentKitModal;
/**
 * Any element that can be used as children.
 */
export declare type ContentKitDescendantElement = ContentKitButton | ContentKitTextInput | ContentKitHStack | ContentKitVStack | ContentKitBox | ContentKitDivider | ContentKitWebFrame | ContentKitCodeBlock | ContentKitMarkdown | ContentKitCard | ContentKitImage | ContentKitInput | ContentKitSelect | ContentKitSwitch | ContentKitCheckbox | ContentKitRadio | ContentKitText;
/**
 * Any element that is inline.
 */
export declare type ContentKitInlineElement = ContentKitText | ContentKitImage;
export declare type QueryParamsType = Record<string | number, any>;
export declare type ResponseFormat = keyof Omit<Body, 'body' | 'bodyUsed'>;
export interface FullRequestParams extends Omit<RequestInit, 'body'> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseFormat;
    /** request body */
    body?: unknown;
    /** base url */
    baseUrl?: string;
    /** request cancellation token */
    cancelToken?: CancelToken;
}
export declare type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>;
export interface ApiConfig<SecurityDataType = unknown> {
    baseUrl?: string;
    baseApiParams?: Omit<RequestParams, 'baseUrl' | 'cancelToken' | 'signal'>;
    securityWorker?: (securityData: SecurityDataType | null) => Promise<RequestParams | void> | RequestParams | void;
    customFetch?: typeof fetch;
}
export interface HttpResponse<D extends unknown, E extends unknown = unknown> extends Response {
    data: D;
    error: E;
}
declare type CancelToken = Symbol | string | number;
export declare enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded"
}
export declare class HttpClient<SecurityDataType = unknown> {
    baseUrl: string;
    private securityData;
    private securityWorker?;
    private abortControllers;
    private customFetch;
    private baseApiParams;
    constructor(apiConfig?: ApiConfig<SecurityDataType>);
    setSecurityData: (data: SecurityDataType | null) => void;
    private encodeQueryParam;
    private addQueryParam;
    private addArrayQueryParam;
    protected toQueryString(rawQuery?: QueryParamsType): string;
    protected addQueryParams(rawQuery?: QueryParamsType): string;
    private contentFormatters;
    private mergeRequestParams;
    private createAbortSignal;
    abortRequest: (cancelToken: CancelToken) => void;
    request: <T = any, E = any>({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }: FullRequestParams) => Promise<HttpResponse<T, E>>;
}
/**
 * @title GitBook API
 * @version 0.0.1-beta
 * @termsOfService https://policies.gitbook.com
 * @baseUrl {host}/v1
 * @contact API Support <support@gitbook.com> (https://gitbook.com/support)
 *
 * The GitBook API
 */
export declare class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    /**
     * @description Access the release version and build date of the GitBook codebase
     *
     * @tags api
     * @name GetApiInformation
     * @summary Get information about the state of the GitBook API
     * @request GET:/
     * @secure
     */
    getApiInformation: (params?: RequestParams) => Promise<HttpResponse<ApiInformation, Error>>;
    search: {
        /**
         * No description
         *
         * @tags search
         * @name SearchContent
         * @summary Search content across spaces that is accessible by the currently authenticated target
         * @request GET:/search
         * @secure
         */
        searchContent: (query: {
            query: string;
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SearchSpaceResult[];
        }, Error>>;
        /**
         * No description
         *
         * @name AskQuery
         * @summary Ask a question to an AI across spaces that is accessible by the currently authenticated target.
         * @request GET:/search/ask
         * @secure
         */
        askQuery: (query: {
            query: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            answer?: SearchAIAnswer;
        }, Error>>;
    };
    user: {
        /**
         * @description Returns details about the user associated with the authentication provided in the request's authorization header.
         *
         * @tags users
         * @name GetAuthenticatedUser
         * @summary Get profile of authenticated user
         * @request GET:/user
         * @secure
         */
        getAuthenticatedUser: (params?: RequestParams) => Promise<HttpResponse<User, Error>>;
        /**
         * @description Lists spaces that the authenticated user explicitly own.
         *
         * @tags users
         * @name ListSpacesForAuthenticatedUser
         * @summary List spaces for the authenticated user
         * @request GET:/user/spaces
         * @secure
         */
        listSpacesForAuthenticatedUser: (query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Space[];
        }, Error>>;
    };
    users: {
        /**
         * @description Provides publicly available information about someone with a GitBook account.
         *
         * @tags users
         * @name GetUserById
         * @summary Get a user by its ID
         * @request GET:/users/{userId}
         * @secure
         */
        getUserById: (userId: string, params?: RequestParams) => Promise<HttpResponse<User, Error>>;
    };
    spaces: {
        /**
         * No description
         *
         * @tags spaces
         * @name GetSpaceById
         * @summary Get the details about a space.
         * @request GET:/spaces/{spaceId}
         * @secure
         */
        getSpaceById: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<Space, Error>>;
        /**
         * No description
         *
         * @name SearchSpaceContent
         * @summary Search content in a space
         * @request GET:/spaces/{spaceId}/search
         * @secure
         */
        searchSpaceContent: (spaceId: string, query: {
            query: string;
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SearchPageResult[];
        }, Error>>;
        /**
         * No description
         *
         * @name AskQueryInSpace
         * @summary Ask a question to an AI within the context of the space.
         * @request GET:/spaces/{spaceId}/search/ask
         * @secure
         */
        askQueryInSpace: (spaceId: string, query: {
            query: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            answer?: SearchAIAnswer;
        }, Error>>;
        /**
         * No description
         *
         * @tags spaces
         * @name ImportGitRepository
         * @summary Import a Git repository
         * @request POST:/spaces/{spaceId}/git/import
         * @secure
         */
        importGitRepository: (spaceId: string, data: RequestImportGitRepository, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @tags spaces
         * @name ExportToGitRepository
         * @summary Export the space content to a Git repository.
         * @request POST:/spaces/{spaceId}/git/export
         * @secure
         */
        exportToGitRepository: (spaceId: string, data: RequestExportToGitRepository, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @tags analytics, spaces
         * @name GetContentAnalyticsForSpaceById
         * @summary Get content analytics for a given space.
         * @request GET:/spaces/{spaceId}/insights/content
         * @secure
         */
        getContentAnalyticsForSpaceById: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<AnalyticsContentPages, Error>>;
        /**
         * No description
         *
         * @tags analytics, spaces
         * @name GetSearchAnalyticsForSpaceById
         * @summary Get an overview of the top search queries in a space.
         * @request GET:/spaces/{spaceId}/insights/search
         * @secure
         */
        getSearchAnalyticsForSpaceById: (spaceId: string, query?: {
            period?: AnalyticsSearchPeriod;
        }, params?: RequestParams) => Promise<HttpResponse<AnalyticsTopSearches, Error>>;
        /**
         * @description Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
         *
         * @tags analytics, spaces
         * @name GetTrafficAnalyticsForSpaceById
         * @summary Get traffic page views for a given space
         * @request GET:/spaces/{spaceId}/insights/traffic
         * @secure
         */
        getTrafficAnalyticsForSpaceById: (spaceId: string, query?: {
            interval?: AnalyticsTrafficInterval;
        }, params?: RequestParams) => Promise<HttpResponse<AnalyticsTrafficPageViews, Error>>;
        /**
         * @description Track a page view in a space.
         *
         * @tags analytics, spaces
         * @name TrackViewInSpaceById
         * @request POST:/spaces/{spaceId}/insights/track_view
         * @secure
         */
        trackViewInSpaceById: (spaceId: string, data: RequestSpaceTrackPageView, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @name GetCurrentRevision
         * @summary Get the current primary content revision for a space
         * @request GET:/spaces/{spaceId}/content
         * @secure
         */
        getCurrentRevision: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<Revision, Error>>;
        /**
         * No description
         *
         * @name ImportContent
         * @summary Import content in a space.
         * @request POST:/spaces/{spaceId}/content/import
         * @secure
         */
        importContent: (spaceId: string, data: RequestImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, Error>>;
        /**
         * No description
         *
         * @name ListFiles
         * @summary List all files for the latest primary revision content for a space
         * @request GET:/spaces/{spaceId}/content/files
         * @secure
         */
        listFiles: (spaceId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: RevisionFile[];
        }, Error>>;
        /**
         * No description
         *
         * @name GetPageById
         * @summary Get a page by its ID in the primary content.
         * @request GET:/spaces/{spaceId}/content/page/{pageId}
         * @secure
         */
        getPageById: (spaceId: string, pageId: string, query?: {
            format?: 'document' | 'markdown';
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPage, Error>>;
        /**
         * No description
         *
         * @name ImportContentInPageById
         * @summary Import external content into a page by its ID.
         * @request POST:/spaces/{spaceId}/content/page/{pageId}/import
         * @secure
         */
        importContentInPageById: (spaceId: string, pageId: string, data: RequestImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, Error>>;
        /**
         * No description
         *
         * @name GetPageByPath
         * @summary Get a page by its path in the primary content.
         * @request GET:/spaces/{spaceId}/content/path/{pagePath}
         * @secure
         */
        getPageByPath: (spaceId: string, pagePath: string, query?: {
            format?: 'document' | 'markdown';
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPageSheet | RevisionPageGroup, Error>>;
        /**
         * No description
         *
         * @tags spaces
         * @name CreateChangeRequest
         * @summary Create a new change request for a space.
         * @request POST:/spaces/{spaceId}/change-requests
         * @secure
         */
        createChangeRequest: (spaceId: string, data: RequestCreateChangeRequest, params?: RequestParams) => Promise<HttpResponse<ChangeRequest & {
            changeRequest: string;
        }, Error>>;
        /**
         * No description
         *
         * @tags spaces
         * @name MergeChangeRequest
         * @summary Merge a change request in the primary content of a space.
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/merge
         * @secure
         */
        mergeChangeRequest: (spaceId: string, changeRequestId: string | number, params?: RequestParams) => Promise<HttpResponse<{
            revision: string;
            result: 'merge' | 'conflicts';
        }, Error>>;
        /**
         * No description
         *
         * @tags spaces
         * @name UpdateChangeRequest
         * @summary Update a change-request with changes from primary content.
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/update
         * @secure
         */
        updateChangeRequest: (spaceId: string, changeRequestId: string | number, params?: RequestParams) => Promise<HttpResponse<{
            revision: string;
            result: 'update' | 'conflicts';
        }, Error>>;
        /**
         * No description
         *
         * @name GetRevisionOfChangeRequestById
         * @summary Get the latest content revision for a change request.
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content
         * @secure
         */
        getRevisionOfChangeRequestById: (spaceId: string, changeRequestId: string | number, params?: RequestParams) => Promise<HttpResponse<Revision, Error>>;
        /**
         * No description
         *
         * @name ImportContentInChangeRequest
         * @summary Import content in a change request.
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/content/import
         * @secure
         */
        importContentInChangeRequest: (spaceId: string, changeRequestId: string | number, data: RequestImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, Error>>;
        /**
         * No description
         *
         * @name ListFilesInChangeRequestById
         * @summary List all files in the latest content of the change-request
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/files
         * @secure
         */
        listFilesInChangeRequestById: (spaceId: string, changeRequestId: string | number, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: RevisionFile[];
        }, Error>>;
        /**
         * No description
         *
         * @name GetPageInChangeRequestById
         * @summary Get a page by its ID in a change request.
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/page/{pageId}
         * @secure
         */
        getPageInChangeRequestById: (spaceId: string, changeRequestId: string | number, pageId: string, query?: {
            format?: 'document' | 'markdown';
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPage, Error>>;
        /**
         * No description
         *
         * @name ImportContentInChangeRequestPageById
         * @summary Import external content into a page of a change-request by its ID.
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/content/page/{pageId}/import
         * @secure
         */
        importContentInChangeRequestPageById: (spaceId: string, changeRequestId: string | number, pageId: string, data: RequestImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, Error>>;
        /**
         * No description
         *
         * @name GetPageInChangeRequestByPath
         * @summary Get a page by its path in a change request.
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/path/{pagePath}
         * @secure
         */
        getPageInChangeRequestByPath: (spaceId: string, changeRequestId: string | number, pagePath: string, query?: {
            format?: 'document' | 'markdown';
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPageSheet | RevisionPageGroup, Error>>;
        /**
         * No description
         *
         * @name GetRevisionById
         * @summary Get a specific revision in a space
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}
         * @secure
         */
        getRevisionById: (spaceId: string, revisionId: string, params?: RequestParams) => Promise<HttpResponse<Revision, Error>>;
        /**
         * No description
         *
         * @name ListFilesInRevisionById
         * @summary List all files in a revision
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/files
         * @secure
         */
        listFilesInRevisionById: (spaceId: string, revisionId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: RevisionFile[];
        }, Error>>;
        /**
         * No description
         *
         * @name GetPageInRevisionById
         * @summary Get a page by its ID in a revision.
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/page/{pageId}
         * @secure
         */
        getPageInRevisionById: (spaceId: string, revisionId: string, pageId: string, query?: {
            format?: 'document' | 'markdown';
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPage, Error>>;
        /**
         * No description
         *
         * @name GetPageInRevisionByPath
         * @summary Get a page by its path in a revision.
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/path/{pagePath}
         * @secure
         */
        getPageInRevisionByPath: (spaceId: string, revisionId: string, pagePath: string, query?: {
            format?: 'document' | 'markdown';
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPageSheet | RevisionPageGroup, Error>>;
        /**
         * No description
         *
         * @tags permissions, spaces
         * @name ListPermissionsAggregateInSpace
         * @summary List permissions for all users in a space.
         * @request GET:/spaces/{spaceId}/permissions/aggregate
         * @secure
         */
        listPermissionsAggregateInSpace: (spaceId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContentPermission[];
        }, Error>>;
    };
    collections: {
        /**
         * No description
         *
         * @tags collections
         * @name GetCollectionById
         * @summary Get the details about a collection using its ID
         * @request GET:/collections/{collectionId}
         * @secure
         */
        getCollectionById: (collectionId: string, params?: RequestParams) => Promise<HttpResponse<Collection, Error>>;
        /**
         * No description
         *
         * @tags collections
         * @name ListSpacesInCollectionById
         * @summary List all the spaces in a collection by its ID.
         * @request GET:/collections/{collectionId}/spaces
         * @secure
         */
        listSpacesInCollectionById: (collectionId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Space[];
        }, Error>>;
        /**
         * No description
         *
         * @tags permissions, spaces
         * @name ListPermissionsAggregateInCollection
         * @summary List permissions for all users in a collection.
         * @request GET:/collections/{collectionId}/permissions/aggregate
         * @secure
         */
        listPermissionsAggregateInCollection: (collectionId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContentPermission[];
        }, Error>>;
    };
    integrations: {
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrations
         * @summary List all public integrations
         * @request GET:/integrations
         * @secure
         */
        listIntegrations: (query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Integration[];
        }, Error>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetIntegrationByName
         * @summary Get a specific integration by its name
         * @request GET:/integrations/{integrationName}
         * @secure
         */
        getIntegrationByName: (integrationName: string, params?: RequestParams) => Promise<HttpResponse<Integration, Error | {
            error: {
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name PublishIntegration
         * @summary Publish an integration
         * @request POST:/integrations/{integrationName}
         * @secure
         */
        publishIntegration: (integrationName: string, data: RequestPublishIntegration, params?: RequestParams) => Promise<HttpResponse<Integration, Error | {
            error: {
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UnpublishIntegration
         * @summary Unpublish an integration
         * @request DELETE:/integrations/{integrationName}
         * @secure
         */
        unpublishIntegration: (integrationName: string, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationInstallations
         * @summary Fetch a list of installations of an integration
         * @request GET:/integrations/{integrationName}/installations
         * @secure
         */
        listIntegrationInstallations: (integrationName: string, query?: {
            page?: string;
            limit?: number;
            externalId?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationInstallation[];
        }, Error>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationSpaceInstallations
         * @summary Fetch a list of space installations of an integration
         * @request GET:/integrations/{integrationName}/spaces
         * @secure
         */
        listIntegrationSpaceInstallations: (integrationName: string, query?: {
            page?: string;
            limit?: number;
            externalId?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationSpaceInstallation[];
        }, Error>>;
        /**
         * No description
         *
         * @name RenderIntegrationUiWithGet
         * @summary Render an integration UI in the context of an installation.
         * @request GET:/integrations/{integrationName}/render
         * @secure
         */
        renderIntegrationUiWithGet: (integrationName: string, query: {
            request: string;
        }, params?: RequestParams) => Promise<HttpResponse<ContentKitRenderOutput, Error>>;
        /**
         * No description
         *
         * @name RenderIntegrationUiWithPost
         * @summary Render an integration UI in the context of an installation.
         * @request POST:/integrations/{integrationName}/render
         * @secure
         */
        renderIntegrationUiWithPost: (integrationName: string, data: RequestRenderIntegrationUI, params?: RequestParams) => Promise<HttpResponse<ContentKitRenderOutput, Error>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UpdateIntegrationInstallation
         * @summary Update external IDs and configurations of an integration's installation
         * @request PATCH:/integrations/{integrationName}/installations/{installationId}
         * @secure
         */
        updateIntegrationInstallation: (integrationName: string, installationId: string, data: RequestUpdateIntegrationInstallation, params?: RequestParams) => Promise<HttpResponse<IntegrationInstallation, Error>>;
        /**
         * @description Creates a temporary API token of an integration's installation that has access to the installation and it's scopes. You must be authenticated as the integration to obtain this token.
         *
         * @tags integrations
         * @name CreateIntegrationInstallationToken
         * @summary Create an integration installation API token
         * @request POST:/integrations/{integrationName}/installations/{installationId}/tokens
         * @secure
         */
        createIntegrationInstallationToken: (integrationName: string, installationId: string, params?: RequestParams) => Promise<HttpResponse<APITemporaryToken, Error | {
            error: {
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @name UpdateIntegrationSpaceInstallation
         * @summary Update external IDs and configurations of an integration's installation for a space
         * @request PATCH:/integrations/{integrationName}/installations/{installationId}/spaces/{spaceId}
         * @secure
         */
        updateIntegrationSpaceInstallation: (integrationName: string, installationId: string, spaceId: string, data: RequestUpdateIntegrationInstallation, params?: RequestParams) => Promise<HttpResponse<IntegrationSpaceInstallation, Error>>;
    };
    orgs: {
        /**
         * No description
         *
         * @tags organizations
         * @name ListOrganizationsForAuthenticatedUser
         * @summary Get the list of organizations for the currently authenticated user
         * @request GET:/orgs
         * @secure
         */
        listOrganizationsForAuthenticatedUser: (query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Organization[];
        }, Error>>;
        /**
         * @description Lists members for the specified organization.
         *
         * @tags organizations
         * @name ListMembersInOrganizationById
         * @summary List organization members
         * @request GET:/orgs/{organizationId}/members
         * @secure
         */
        listMembersInOrganizationById: (organizationId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationMember[];
        }, Error>>;
        /**
         * @description Gets a specific member in an organization.
         *
         * @tags organizations
         * @name GetMemberInOrganizationById
         * @summary Get specified organization member
         * @request GET:/orgs/{organizationId}/members/{userId}
         * @secure
         */
        getMemberInOrganizationById: (organizationId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationMember, Error>>;
        /**
         * @description Updates a specific member in an organization.
         *
         * @tags organizations
         * @name UpdateMemberInOrganizationById
         * @summary Update specified organization member
         * @request PATCH:/orgs/{organizationId}/members/{userId}
         * @secure
         */
        updateMemberInOrganizationById: (organizationId: string, userId: string, data: {
            role?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationMember, Error>>;
        /**
         * @description Deletes a specific member from an organization
         *
         * @tags organizations
         * @name RemoveMemberFromOrganizationById
         * @summary Delete a member from an organization
         * @request DELETE:/orgs/{organizationId}/members/{userId}
         * @secure
         */
        removeMemberFromOrganizationById: (organizationId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name SetUserAsSsoMemberForOrganization
         * @summary Set a user as an SSO member of an organization
         * @request POST:/orgs/{organizationId}/members/{userId}/sso
         * @secure
         */
        setUserAsSsoMemberForOrganization: (organizationId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @tags permissions, spaces
         * @name ListSpacesForOrganizationMember
         * @summary List permissions accross all spaces for a member of an organization
         * @request GET:/orgs/{organizationId}/members/{userId}/spaces
         * @secure
         */
        listSpacesForOrganizationMember: (organizationId: string, userId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: MemberContentPermission[];
        }, Error>>;
        /**
         * @description Lists teams for the specified organization.
         *
         * @tags organizations
         * @name ListTeamsInOrganizationById
         * @summary List organization teams
         * @request GET:/orgs/{organizationId}/teams
         * @secure
         */
        listTeamsInOrganizationById: (organizationId: string, query?: {
            page?: string;
            limit?: number;
            title?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationTeam[];
        }, Error>>;
        /**
         * @description Creates a team in the specified organization.
         *
         * @tags organizations
         * @name CreateOrganizationTeam
         * @summary Create organization team
         * @request PUT:/orgs/{organizationId}/teams
         * @secure
         */
        createOrganizationTeam: (organizationId: string, data: {
            title: string;
            members?: string[];
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationTeam, Error>>;
        /**
         * @description Gets a specific team in an organization.
         *
         * @tags organizations
         * @name GetTeamInOrganizationById
         * @summary Get specified organization team
         * @request GET:/orgs/{organizationId}/teams/{teamId}
         * @secure
         */
        getTeamInOrganizationById: (organizationId: string, teamId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationTeam, Error>>;
        /**
         * @description Updates a specific team in an organization.
         *
         * @tags organizations
         * @name UpdateTeamInOrganizationById
         * @summary Update specified organization team
         * @request PATCH:/orgs/{organizationId}/teams/{teamId}
         * @secure
         */
        updateTeamInOrganizationById: (organizationId: string, teamId: string, data: {
            title: string;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationTeam, Error>>;
        /**
         * @description Deletes a specific team in an organization
         *
         * @tags organizations
         * @name RemoveTeamFromOrganizationById
         * @summary Delete a team in an organization
         * @request DELETE:/orgs/{organizationId}/teams/{teamId}
         * @secure
         */
        removeTeamFromOrganizationById: (organizationId: string, teamId: string, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * @description Updates members of an organization team, either adding or removing them. If a the same user is included as both an add and a remove, they will be removed from the team.
         *
         * @tags organizations
         * @name UpdateMembersInOrganizationTeam
         * @summary Updates members of an organization team
         * @request PUT:/orgs/{organizationId}/teams/{teamId}/members
         * @secure
         */
        updateMembersInOrganizationTeam: (organizationId: string, teamId: string, data: {
            add?: string[];
            remove?: string[];
        }, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * @description Lists members for the specified organization team.
         *
         * @tags organizations
         * @name ListTeamMembersInOrganizationById
         * @summary List team members
         * @request GET:/orgs/{organizationId}/teams/{teamId}/members
         * @secure
         */
        listTeamMembersInOrganizationById: (organizationId: string, teamId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationMember[];
        }, Error>>;
        /**
         * @description Adds member into the specified organization team.
         *
         * @tags organizations
         * @name AddMemberToOrganizationTeamById
         * @summary Add member to a team
         * @request PUT:/orgs/{organizationId}/teams/{teamId}/members/{userId}
         * @secure
         */
        addMemberToOrganizationTeamById: (organizationId: string, teamId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * @description Deletes member from the specified organization team.
         *
         * @tags organizations
         * @name DeleteMemberFromOrganizationTeamById
         * @summary Delete members from a team
         * @request DELETE:/orgs/{organizationId}/teams/{teamId}/members/{userId}
         * @secure
         */
        deleteMemberFromOrganizationTeamById: (organizationId: string, teamId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name InviteUsersToOrganization
         * @summary Invite users to a given organization based on a list of emails
         * @request POST:/orgs/{organizationId}/invites
         * @secure
         */
        inviteUsersToOrganization: (organizationId: string, data: RequestInviteUsersToOrganization, params?: RequestParams) => Promise<HttpResponse<{
            users: string[];
            invited: number;
            failedSSOEmails?: string[];
        }, Error | {
            error: {
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags organizations
         * @name JoinOrganizationWithInvite
         * @summary Use an invite to join an organization.
         * @request POST:/orgs/{organizationId}/invites/{inviteId}
         * @secure
         */
        joinOrganizationWithInvite: (organizationId: string, inviteId: string, params?: RequestParams) => Promise<HttpResponse<object, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name UpgradeOrganizationPlan
         * @summary Upgrade an organization's billing plan
         * @request POST:/orgs/{organizationId}/billing
         * @secure
         */
        upgradeOrganizationPlan: (organizationId: string, data: RequestUpgradeOrganizationBilling, params?: RequestParams) => Promise<HttpResponse<BillingUpgrade, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name GetOrganizationBillingPortal
         * @summary Get the billing portal for an organization
         * @request GET:/orgs/{organizationId}/billing
         * @secure
         */
        getOrganizationBillingPortal: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<BillingPortal, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name RequestOrganizationUpgrade
         * @summary Send a request to ask the organization's admin to upgrade it.
         * @request POST:/orgs/{organizationId}/request_upgrade
         * @secure
         */
        requestOrganizationUpgrade: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<object, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name TransferOrganization
         * @summary Transfer one organization (source) into another organization (target).
         * @request POST:/orgs/{organizationId}/transfer
         * @secure
         */
        transferOrganization: (organizationId: string, data: {
            source: string;
            defaultOrgRole?: MemberRoleOrGuest | 'saml';
        }, params?: RequestParams) => Promise<HttpResponse<{
            collection: string;
            newSourceHostname?: string;
        }, Error>>;
        /**
         * No description
         *
         * @tags organizations
         * @name SearchOrganizationContent
         * @summary Search content in an organization
         * @request GET:/orgs/{organizationId}/search
         * @secure
         */
        searchOrganizationContent: (organizationId: string, query: {
            query: string;
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SearchSpaceResult[];
        }, Error>>;
        /**
         * @description Lists spaces for the specified organization.
         *
         * @tags organizations
         * @name ListSpacesInOrganizationById
         * @summary List organization spaces
         * @request GET:/orgs/{organizationId}/spaces
         * @secure
         */
        listSpacesInOrganizationById: (organizationId: string, query?: {
            page?: string;
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Space[];
        }, Error>>;
        /**
         * @description Lists collections for the specified organization.
         *
         * @tags organizations
         * @name ListCollectionsInOrganizationById
         * @summary List organization collections
         * @request GET:/orgs/{organizationId}/collections
         * @secure
         */
        listCollectionsInOrganizationById: (organizationId: string, query?: {
            page?: string;
            limit?: number;
            nested?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Collection[];
        }, Error>>;
        /**
         * No description
         *
         * @tags organizations, dsync
         * @name SetupDirectorySync
         * @summary Set up Directory Sync in an organization.
         * @request POST:/orgs/{organizationId}/dsync
         * @secure
         */
        setupDirectorySync: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<{
            setupUrl: string;
        }, Error>>;
        /**
         * No description
         *
         * @tags organizations, dsync
         * @name ListDirectorySyncGroups
         * @summary Lists the groups exposed to the synced Directory on an organization.
         * @request GET:/orgs/{organizationId}/dsync/groups
         * @secure
         */
        listDirectorySyncGroups: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<{
            groups: OrganizationDirectorySyncGroup[];
        }, Error>>;
        /**
         * @description Each pair will lead the team being synced to the group (unless it is already synced to another) and the members of the group will then be synced to the team. Each sync is independent, the endpoint will still succeed if some of the syncs fail. Check the response to know more about the success or failure of the entire sync.
         *
         * @tags organizations, dsync
         * @name SyncDirectorySyncGroupsToTeams
         * @summary Syncs a list of group/team unique identifiers pairs together.
         * @request POST:/orgs/{organizationId}/dsync/teams
         * @secure
         */
        syncDirectorySyncGroupsToTeams: (organizationId: string, data: {
            to_sync: {
                group_id: string;
                team_id?: string;
            }[];
        }, params?: RequestParams) => Promise<HttpResponse<{
            synced: OrganizationDirectorySyncGroupTeamStatus[];
        }, Error>>;
    };
    urls: {
        /**
         * No description
         *
         * @tags urls
         * @name GetContentByUrl
         * @summary Resolve a URL to a content (space, collection, page)
         * @request GET:/urls/content
         * @secure
         */
        getContentByUrl: (query: {
            url: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            collection: Collection;
        } | {
            space: Space;
            changeRequest?: ChangeRequest;
            page?: RevisionPageSheet | RevisionPageGroup;
        }, Error>>;
    };
}
export {};
